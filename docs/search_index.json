[["index.html", "Interactive data with Shiny flexdashboard Overview 0.1 Set up", " Interactive data with Shiny flexdashboard Liza Wood 2023-10-12 Overview This lesson is meant to be a cursory look at creating interactive dashboards using RMarkdown + flexdashboard with Shiny integration. Roughly we will… Introduce and discuss interactive sites (5 minutes) Overview of flexdashboard and its layout scheme (10) Create a dashboard with static interaction (does not rely on Shiny) (10) Create a dashboard with dynamic interaction (does rely on Shiny) (30) Themes and styles (5) Publishing (10) A note on Shiny: The focus of this lesson is integrating elements of Shiny through the RMarkdown interface, which is different than learning Shiny outright. is among the more popular ways of creating interactive sites because it provides a server on which you can host for free (up to a limit). So it is a popular starting point, though … Shiny can be coded in R in (what I understand) are two main ways. One that relies on the coder’s ability to design the architecture through scripting in R and X, where you create the user interface, the server, a web app that links them. A second option relies on the flexdashboard package, which makes dashboard creation through RMarkdown much easier on several fronts, including Shiny. This lesson is going to focus on the latter. 0.1 Set up 0.1.1 Package installation It will be useful to make sure the following packages are installed, especially if your computer is sometimes buggy downloading packages. install.packages(&#39;tidyverse&#39;) install.packages(&#39;palmerpenguins&#39;) install.packages(&#39;plotly&#39;) install.packages(&#39;flexdashboard&#39;) 0.1.2 shinyapps.io account If you want to actually publish the page we make in this lesson, you will need to create a Shiny account and link it to your RStudio. To do this, please complete the following steps: create a Shiny account Follow the instructions for publishing in RStudio by navigating to Tools &gt; Global Options &gt; Publishing. Once on this pane, you’ll click Connect &gt; shinyapps.io and follow the instructions to link your account. "],["why-interactive-sites.html", "1 Why interactive sites? 1.1 Communication and personalization 1.2 Teaching", " 1 Why interactive sites? We often find ourselves looking at data and realize that there are a million and one ways to visualize it. As scientists, we are supposed to decide which story to pluck out. What this means is that we end up settling on 1-2 plots, each of which only 2-4 dimensions: and x and y axis, and sometimes a coloring or faceting that adds richness to those dimensions. While part of being a scientist is deciding on what dimensions are important for story you think your data tells, part of being a science communicator, teacher, and an open is finding ways to engage with the multi-dimensionality of a story. Interactive data sites can help us do that, particularly for communication/personalization and teaching. 1.1 Communication and personalization Often data doesn’t have just one story. Readers don’t want to know about the average, or how something compares against a baseline that is irrelevant for them. People want to know how data relates to their lives and their interests. Interactive data sites let users be in control of what they want to see. For example: UC Davis TA/GSR pay estimator lets students see their potential wages based on their own starting conditions State of Organic Seed Report interactive data lets stakeholders view statistics most relevant to them (e.g. crops, regions, etc.) 1.2 Teaching Interaction is also an incredible tool for teaching. It allows us to see outcomes across several scenarios, see how relationshps shift when new variables are added, etc. Some examples I like include: Michael Levy’s demonstration of how network parameters and hyperparameters relate to the shape of a network in a certain modeling technique Sam Zhang’s exploration of geometry of motion based on cats falling off ladders Chelsae Pelleriti’s demonstration of how different classification algorithms create different decision boundaries and vary based on parameters1 P.S. Chelsea has one of the most entertaining online presences re: stats and coding @ChelseaParlett↩︎ "],["flexdashboard.html", "2 Flexdashboard 2.1 Layout", " 2 Flexdashboard 2.1 Layout To start, we aren’t even going to think about Shint yet. We are going to focus on flexdashboard. Several different versions of layouts can be viewed on the Flexdashboard layout page. The basic idea of the dashboard is that you can have any number of blocks that hold different information, across one or several tabs or pages. We are going to start with the simplest layout setup as a blank canvas. To get started, open up a blank Rmd document and paste in the following. Notice these are a few important elements YAML: The part that starts and ends with three dashes --- is something special to Rmds. This is true also if you’ve worked with Rmds to make ‘notebooks’ or PDF docments. The YAML specifies metadata about the document and its format. For our sake, the new things you’ll see are that we add an output specification to flexdashboard::flex_dashboard: Comments: You probably know that to comment in R scripts, we use hashtags (#). But because hashtagssignify headers in markdown language, we use arrows and dashes to comments on &lt;!--- info I want to omit ---&gt; Headers: Because hashtags mean headers, we use them to denote nested headings. In the dashboard, the title in the YAML is implictly the first header (#) and so we start with secondary headers (##) to identify the formatting shapes in the dashboard, using the words ‘Column’ or ‘Row’. We can give the format special instructions after the secondary headers inside curly brackets {}. --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: --- &lt;!--- We are in Rmd so hash tags don&#39;t work as comments. They denote different levels of headers. Instead use these ---&gt; &lt;!--- ## is a formatting header, but these don&#39;t actually get names. The sidebar denotation is a special format for where folks usually put sidebars. We&#39;ll see how different this looks in a moment. ---&gt; ## Column {.sidebar} This is where the sliders go ## Column &lt;!--- ### is where you can actually give units names ---&gt; ### Relationship between penguin bill length and depth We can add a figure in here shortly If we hit the knit button, we should render something like this: Now, take a look at the layout formatting webpage and play around a little. For instance: How do you add more boxes? What happens if you add a ‘Row’ like you did a column? How can you add another tab? These are generally easy-enough to learn through looking through the page linked above, so we won’t dwell here. "],["static-interaction.html", "3 Static interaction", " 3 Static interaction So far, our dashboard doesn’t have any interactive content – we only have shapes and some text. What we want to do next is add in a figure so that we can work words interactivity. Our first focus will be on plots that can be interacted with using wrapper functions like plotly and 3D, but aren’t actually dynamic – meaning they don’t respond to the user yet. For instance, you might want to just show off some graphs and let folks have a peek at the underlying data, but not actually change the shape or variables represented in the data. Here are some examples: https://testing-apps.shinyapps.io/flexdashboard-dygraphs/ https://testing-apps.shinyapps.io/flexdashboard-highcharter/ We do this by adding in code chunks to our Rmd. Feel free to paste in all of this code to your Rmd document again, or paste only the new code chunk. --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) ``` ## Column {.sidebar} ## Column ### Relationship between penguin bill length and depth ```{r} ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) ``` So now we have a plot embedded in our dashboard. But we can’t do anything with it yet. The first entry point to making this interactive to use wrapper functions. For instance, you may have played with the plotly package before. We can wrap the function ggplotly around our ggplot to convert the static ggplot to an intractive one, where we can explore the values behind each data point. ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;)) ``` Further, plotly has lots of capacities, so just a teaser is that we can play around with the tooltip argument in ggplotly to adjust what users see. ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;), tooltip = c(&quot;x&quot;)) ``` There are other interactive packages like plotly, namely leaflet for maps and networkD3 for networks. ### Penguins by island ```{r} penguins %&gt;% cbind(select(penguins_raw, `Individual ID`)) %&gt;% filter(year == 2007) %&gt;% select(`Individual ID`, island, species) %&gt;% networkD3::simpleNetwork( charge = -5, fontSize = 8, fontFamily = &quot;Times&quot;, linkColour = &quot;#666&quot;, nodeColour = &quot;#51127C&quot;, opacity = 0.9, zoom = T ) ``` Now, what we’ve done so far is cool – using just flexdashboard and something like plotly or you can build this out and make pretty cool semi-static pages. Reveal source code --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) ``` ## Row {data-height=300} ### The data {data-width=700} The Palmer Station penguins data is a tidy data set related to three species of Antarctic penguins from Horst, Hill, and Gorman (2020). The data contains size measurements for male and female adult foraging Adélie, Chinstrap, and Gentoo penguins observed on islands in the Palmer Archipelago near Palmer Station, Antarctica between 2007-2009. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. You can read more about the package [here](https://allisonhorst.github.io/palmerpenguins/index.html). ### {data-width=300} ```{r, fig.cap=&quot;@allisonhorst&quot;} knitr::include_graphics(&quot;https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/man/figures/culmen_depth.png&quot;) ``` ## Row {data-height=700} ### Relationship between penguin bill length and depth ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;)) ``` ### Penguins by island ```{r} ColourScale &lt;- &#39;d3.scaleOrdinal() .domain([&quot;&quot;, &quot;tigers&quot;]) .range([&quot;#FF6900&quot;, &quot;#694489&quot;]);&#39; penguins %&gt;% cbind(select(penguins_raw, `Individual ID`)) %&gt;% filter(year == 2007) %&gt;% select(`Individual ID`, island, species) %&gt;% networkD3::simpleNetwork( charge = -5, fontSize = 8, fontFamily = &quot;Times&quot;, linkColour = &quot;#666&quot;, nodeColour = &quot;#FB8861&quot;, opacity = 0.9, zoom = T ) ``` But, we haven’t really gotten into the dynamic user-interfacing with data that is makes this more useful. And because of this, note that we haven’t even gotten into the world of Shiny yet! So, that’s what’s next… "],["dynamic-interaction.html", "4 Dynamic interaction 4.1 User interface 4.2 Server output 4.3 Interaction can be more than filtering", " 4 Dynamic interaction Next we make things dynamic, which means we enter the world of Shiny2. The jump here is that we go from being able to hover over and drag around our images, to allowing users to interact with the data. To do that we need two ingredients: Input / user-interface Output / back-end Generally you will ahve to iterate between these two sides to get the result you want. I usually like to start by close your eyes and imagine: What do I want users to manipulate? Year Species Island Here, we’re going to keep only 2 base dimensions, but alter the figure based on: species, island, and year So in total, users will be able to make 64 different plots based on all combinations of species, islands, and years. But because the species (4) x islands (4) x years (4) 4.1 User interface The UI specific the input Not all of these are screen-reader friendly To set up the page, we can specify these options using the various select series of functions. There are different kinds of selectors… let’s use a basic one --- title: &#39;Palmer Penguin Dashboard&#39; runtime: shiny output: flexdashboard::flex_dashboard: --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) ``` ## Column {.sidebar} ```{r} selectInput(&quot;species&quot;, &quot;Species&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$species))), selected=&quot;All&quot;, multiple=F) ``` What this does under the hood is actually create a data frame called input, which different columns that specify each condition. so based on what we select, we’re creating a data frame like this: input &lt;- data.frame(&#39;species&#39; = c(&quot;All&quot;, unique(as.character(penguins$species)))) input ## species ## 1 All ## 2 Adelie ## 3 Gentoo ## 4 Chinstrap So we can add this in and see that the new page changes – we now have a selector. That is th euser end. But it doesn’t work yet because we need to connect it to the back end. 4.2 Server output The mechanics that makes the graph reactive to what we select as an input To connect to the output we need 2 steps: 1. preparing the data 2. wrapping our plot in the right function Preparing the data&gt; You are creating a reactive function called selectedData. You could all this whatever you wanted, really. But the idea is you are creating a function that will create a new data frame every tie the selector inputs are changed. This is the hardest step because it forces you to think about the conditionality and shape of your data ```{r} selectedData &lt;- reactive({ if(input$species == &quot;All&quot;){ penguins } else { penguins %&gt;% filter(species == input$species) } }) ``` Step 2 is easier. We just change two things: 1. we replace our static data with the reactive data function, which we called seleectedData. And then 2. we wrap the whole plot in a function called renderPlot() ```{r} renderPlot({ ggplot(selectedData(), aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) }) ``` Let’s try to do this with several of our laters We add more selectors ```{r} selectInput(&quot;species&quot;, &quot;Species&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$species))), selected=&quot;All&quot;, multiple=F) selectInput(&quot;island&quot;, &quot;Island&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$island))), selected=&quot;All&quot;, multiple=F) selectInput(&quot;year&quot;, &quot;Year&quot;, choices=c(&quot;All&quot;, unique(penguins$year)), selected=&quot;All&quot;, multiple=F) ``` And whenever we add more selectors we have to update our data selection function to react to those selectors ```{r} selectedData &lt;- reactive({ if(input$species == &quot;All&quot;){ penguins_s &lt;- penguins } else { penguins_s &lt;- penguins %&gt;% filter(species == input$species) } if(input$island == &quot;All&quot;){ penguins_si &lt;- penguins_s } else { penguins_si &lt;- penguins_s %&gt;% filter(island == input$island) } if(input$year == &quot;All&quot;){ penguins_siy &lt;- penguins_si } else { penguins_siy &lt;- penguins_si %&gt;% filter(year == input$year) } return(penguins_siy) }) ``` Then we don’t need to change our plot 4.3 Interaction can be more than filtering Let’s say we didn’t just want to filter/reduce the data. What if we wanted to color the points of the plot by different things. Here, we don’t need to have reactive data selection at all, we just need ggplot to respond to the input by adding and elment (or not) ```{r} selectInput(&quot;fill_var&quot;, &quot;Color points by...&quot;, choices=c(&quot;None&quot;, &quot;species&quot;, &quot;island&quot;, &quot;year&quot;), selected=&quot;None&quot;, multiple=F) ``` Now, we only are focusing on one input, input$fill_var. This input value is going to specify if we want to color by anything, and if so, which column. So instead of making the data selection conditional on our input, we can make the plot conditional on the input: ```{r} renderPlot({ if(input$fill_var == &quot;None&quot;){ # Make the same plot as before ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127CF&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) } else { # Add in the input ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = input$fill_var)) + geom_point() + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) } }) ``` BUT, when we try this we get a frustrating result. It is evaluating input$fill_var as text, not as a column name in the data frame. How do we get around this? We have to be very specific with R, telling it to evaluation the text as an object. We don’t get too much into this, but we will do it using these two functions: eval(parse(text = input$fill_var)) So when we add that in, we get what we want: ```{r} renderPlot({ if(input$fill_var == &quot;None&quot;){ # Make the same plot as before ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) } else { # Add in the input, make sure to evaluate the parsed text so that R # thinks of it as a variable and not just text ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = eval(parse(text = input$fill_var)))) + geom_point() + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;, color = &quot;&quot;) } }) ``` BOOKMARK: IN GGPLOT, EACH DIMENSION IS ITS OWN COLUMN Mind the Note in Introduction: We are NOT learning full-blown Shiny.↩︎ "],["themes-and-styling.html", "5 Themes and styling", " 5 Themes and styling "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
