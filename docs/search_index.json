[["index.html", "Interactive data with Shiny flexdashboard Overview Set up", " Interactive data with Shiny flexdashboard Liza Wood 2023-10-19 Overview This lesson is meant to be a cursory look at creating interactive dashboards using RMarkdown + flexdashboard with Shiny integration. Roughly we will… Introduce and discuss interactive sites Overview of flexdashboard and its layout scheme Create a dashboard with static interaction (does not rely on Shiny) Create a dashboard with dynamic interaction (does rely on Shiny) Discuss options for themes and styles Publish the site A note on Shiny: The focus of this lesson is integrating elements of Shiny through the RMarkdown interface via flexdashboard, which is different than learning classic Shiny via the shiny package. More standard tutorials for learning Shiny, such as Posit’s introduction, can show you how to build an app without flexdashboard. Personally, I think learning Shiny via flexdashboard is a good gateway, as it introduces some (but not all) of the concepts needed for more advanced app-building. Set up Package installation It will be useful to make sure the following packages are installed, especially if your computer is sometimes buggy downloading packages. install.packages(&#39;tidyverse&#39;) install.packages(&#39;palmerpenguins&#39;) install.packages(&#39;plotly&#39;) install.packages(&#39;flexdashboard&#39;) install.packages(&#39;shiny&#39;) # worry less about... install.packages(&#39;networkD3&#39;) Make a shinyapps.io account If you want to actually publish the page we make in this lesson, you will need to create a Shiny account and link it to your RStudio. To do this, please complete the following steps: create a Shiny account Follow the instructions for publishing in RStudio by navigating to Tools &gt; Global Options &gt; Publishing. Once on this pane, you’ll click Connect &gt; shinyapps.io and follow the instructions to link your account. Review conditionals This is not essential, but one of the trickiest parts of making documents interactive is setting the right conditionals for re-shaping your data. I would recommend revisiting the logic behind conditional statements in R, which include if...else, ifelse(), and case_when() functions. This tutorial will use the if...else syntax, so maybe worth brushing up on. "],["why-interactive-sites.html", "1 Why interactive sites? 1.1 Communication and personalization 1.2 Teaching", " 1 Why interactive sites? We often find ourselves looking at data and realize that there are a million and one ways to visualize it. As scientists, we are supposed to decide which story to pluck out to make our argument. What this means is that we end up settling on 1-2 plots, each of which has only 2-4 dimensions (e.g. x and y axis, and sometimes a coloring or faceting that adds richness to those dimensions). While part of being a scientist is deciding on what dimensions are important for the story you think your data tells, part of being a science communicator, teacher, and an open data advocate is finding ways to share the multi-dimensionality of a story. Interactive data sites can help us do that, particularly for communicating to wider audiences and teaching. 1.1 Communication and personalization Often data doesn’t have just one story. Readers don’t want to know about the average, or how something compares against a baseline that is irrelevant for them. People want to know how data relates to their lives and their interests. Interactive data sites let users be in control of what they want to see. For example: UC Davis TA/GSR pay estimator lets students see their potential wages based on their own starting conditions State of Organic Seed Report interactive data lets stakeholders view statistics most relevant to them (e.g. crops, regions, etc.) 1.2 Teaching Interaction is also an incredible tool for teaching. It allows us to see outcomes across several scenarios, see how relationshps shift when new variables are added, etc. Some examples I like include: Michael Levy’s demonstration of how network parameters and hyperparameters relate to the shape of a network in a certain modeling technique Chelsae Pelleriti’s demonstration of how different classification algorithms create different decision boundaries and vary based on parameters1 P.S. Chelsea has one of the most entertaining online presences re: stats and coding @ChelseaParlett↩︎ "],["flexdashboard.html", "2 Flexdashboard", " 2 Flexdashboard To start, we are going to focus on flexdashboard: a package for creating sleek ‘dashboard’ pages. The basic idea of the dashboard is that you can have any number of blocks that hold different information, across one or several tabs or pages. Several different types of layouts (and how to code them in Rmd) can be viewed on the Flexdashboard layout page. To get started, open up a blank Rmd document and paste in the following: --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: --- &lt;!--- We are in Rmd so hash tags don&#39;t work as comments. They denote different levels of headers. Instead use these ---&gt; &lt;!--- ## symbol is a formatting header, but these don&#39;t actually get header names. Instead you specify the shape you want with either Column or Row. The {.sidebar} addition is a special format for where folks usually put sidebars. We&#39;ll see how different this looks in a moment. Other shape specifications can do inside the curly brakcets. ---&gt; ## Column {.sidebar} This is where the sliders go ## Column &lt;!--- ### symbol is where you can actually give blocks names ---&gt; ### Relationship between penguin bill length and depth We can add a figure in here shortly Notice these important elements: YAML: The part that starts and ends with three dashes --- is something special to Rmds. This is true also if you’ve worked with Rmds to make ‘notebooks’ or PDF docments. The YAML specifies metadata about the document and its format. For our sake, the new things you’ll see are that we add an output specification to flexdashboard::flex_dashboard: Comments: You probably know that to comment in R scripts, we use hashtags (#). But because hashtagssignify headers in markdown language, we use arrows and dashes to comments on &lt;!--- info I want to omit ---&gt; Headers: Because hashtags mean headers, we use them to denote nested headings. In the dashboard, the title in the YAML is implicitly the first header (#) and so we start with secondary headers (##) to identify the formatting shapes in the dashboard, using the words ‘Column’ or ‘Row’. We can give the format special instructions after the secondary headers inside curly brackets {}. Then actual headers of the different blocks start with tertiary headers (###) If we hit the knit button, we should render something like this: Now, take a look at the layout formatting webpage and play around a little. For instance: How do you add more boxes? What happens if you add a ‘Row’ like you did a ‘Column’? How can you add another tab? These are generally easy-enough to learn through looking through the page linked above, so we won’t dwell here. "],["static-interaction.html", "3 Static interaction", " 3 Static interaction So far, our dashboard doesn’t have any content – we only have boxes and some text. What we want to do next is add in a figure so that we can work towards interactivity. Our first focus will be on plots that can be interacted with using wrapper functions like plotly and networkD3, but aren’t actually dynamic – meaning they don’t respond to the user yet. For instance, you might want to just show off some graphs and let folks have a peek at the underlying data, but not actually change the shape or variables represented in the data. Here are some examples: https://testing-apps.shinyapps.io/flexdashboard-dygraphs/ https://testing-apps.shinyapps.io/flexdashboard-highcharter/ Note that there are loads of examples, all of which share source code (!), available through flexdashboard. To add in figures we can insert code chunks to our Rmd. As in other Rmd formatting, we can also insert a setup chunk where we load in our packages. Feel free to paste in all of this code to your Rmd document again, or paste only the new code chunk. --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) ``` ## Column {.sidebar} ## Column ### Relationship between penguin bill length and depth ```{r} ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) ``` If we click Knit again, now we have a plot embedded in our dashboard. Cool! But we can’t do anything with it yet – it is totally static. The first entry point to making this interactive is to use wrapper functions. For instance, you may have played with the plotly package before. We can wrap the function ggplotly around our ggplot to convert the static ggplot to an intractive one, where we can explore the values behind each data point. ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;)) ``` Further, plotly has lots of capacities, and just one example is that we can play around with the tooltip argument in ggplotly to adjust what users see. ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;), tooltip = c(&quot;x&quot;)) ``` There are other interactive packages like plotly, namely leaflet for maps and networkD3 for networks. You don’t necessarily need to follow along here, but for example, we can manipulate the penguins data a little to make a network figure that we can aslo drag and drop around (though admittedly it is a lame network). ### Penguins by island ```{r} penguins %&gt;% cbind(select(penguins_raw, `Individual ID`)) %&gt;% filter(year == 2007) %&gt;% select(`Individual ID`, island, species) %&gt;% networkD3::simpleNetwork( charge = -5, fontSize = 8, fontFamily = &quot;Times&quot;, linkColour = &quot;#666&quot;, nodeColour = &quot;#51127C&quot;, opacity = 0.9, zoom = T ) ``` Now, what we’ve done so far is cool – using just flexdashboard and something like plotly, you can build this out and make pretty nice semi-static pages. For example, below I show a screenshot of a dashboard, aftering playing around with the ‘row’ formatting of flexdashboard, adding in some text and images and figures. Reveal source code --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) ``` ## Row {data-height=300} ### The data {data-width=700} The Palmer Station penguins data is a tidy data set related to three species of Antarctic penguins from Horst, Hill, and Gorman (2020). The data contains size measurements for male and female adult foraging Adélie, Chinstrap, and Gentoo penguins observed on islands in the Palmer Archipelago near Palmer Station, Antarctica between 2007-2009. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. You can read more about the package [here](https://allisonhorst.github.io/palmerpenguins/index.html). ### {data-width=300} ```{r, fig.cap=&quot;@allisonhorst&quot;} knitr::include_graphics(&quot;https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/man/figures/culmen_depth.png&quot;) ``` ## Row {data-height=700} ### Relationship between penguin bill length and depth ```{r} ggplotly(ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 2, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;)) ``` ### Penguins by island ```{r} penguins %&gt;% cbind(select(penguins_raw, `Individual ID`)) %&gt;% filter(year == 2007) %&gt;% select(`Individual ID`, island, species) %&gt;% networkD3::simpleNetwork( charge = -5, fontSize = 8, fontFamily = &quot;Times&quot;, linkColour = &quot;#666&quot;, nodeColour = &quot;#FB8861&quot;, opacity = 0.9, zoom = T ) ``` But, we haven’t really gotten into the dynamic user-interface, which is the main focus of the lesson. (And because of this, note that we haven’t even gotten into the world of Shiny yet!) So, that’s what’s next… "],["dynamic-interaction.html", "4 Dynamic interaction 4.1 Filtering by attributes 4.2 Selecting by different columns", " 4 Dynamic interaction Next we make things dynamic, which means we enter the world of Shiny2. There is a nice overview of how flexdashboard interacts with Shiny. The jump here is that we go from being able to hover over and drag around our images, to allowing users to interact with the data. To do that we need three ingredients: Input / user-interface Output / back-end runtime: shiny in the YAML Generally you will have to iterate between creating the input and output to get the result you want. A good place to start is usually by imagining one way that you want users to be able to interface with the data. This can take lots of forms. You may want to filter the data based on different attributes, lets users decide different grouping or variables, or alter color schemes. 4.1 Filtering by attributes First, we are going to focus on interactivity that let’s users filter the data, meaning, reduce it to the variables that they are interested in. For this example, we’ll focus on just the baseline plot we’re working with – the relationship between bill length and bill depth – but focus on filtering the data by several different variables, such as species, island, and year. So we’ll keep our base plot with only 2 dimensions, but alter the figure based on those three variables. As an end-result, users will be able to make 64 different plots based on all combinations of species, islands, and years. 4.1.1 Input The input focuses on the user-interface (UI) side – what the user toggles in order to change their view. There are different kinds of inputs that can give you drop-down menus, sliders, text box entries, etc. 3 Table 4.1: Input options from flexdashboard Input function Input type selectInput A box with choices to select from sliderInput A slider bar radioButtons A set of radio buttons textInput A field to enter text numericInput A field to enter numbers checkboxInput A single check box dateInput A calendar to aid date selection dateRangeInput A pair of calendars for selecting a date range fileInput A file upload control wizard So these are functions that we can put into an R chunk, and then fill out the arguments accordingly. You can look at the arguments like this: ?shiny::selectInput Generally, the arguments are the inputID, or the name that will be assigned to a column in a new data frame called input. Then the label, which is what users will see next to the input, choices, which is what users will see with their input selection, and selected can be set to have a default value selected from your list of choices. There are others, but we’ll stick with these for now. So we will add this code chunk into our sidebar column, and first make an input selector for the species of penguins. We provide the choices of “All”, or the unique names of all the penguins in the data frame, and select “All” as the default. Note that we also need to load in the shiny library because the input functions are from Shiny. --- title: &#39;Palmer Penguin Dashboard&#39; output: flexdashboard::flex_dashboard: --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) library(shiny) ``` ## Column {.sidebar} ```{r} selectInput(&quot;species&quot;, &quot;Species&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$species))), selected=&quot;All&quot;, multiple=F) ``` ## Column ### Relationship between penguin bill length and depth ```{r} ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) ``` If we add in the selectInput function and Knit, we can see that we now have a selector on the sidebar. As a user, you can switch it around. BUT it doesn’t work yet because we need to connect it to the back end. 4.1.2 Output To connect to the output figure to the input, we need to do 2 things: 1. Prepare the data 2. Wrap our plot in the right render function Preparing the data is probably the way of thinking that is most important to creating interactive data. The idea is to create a reactive function that filters the data reactive to the input. So a first note is about what actually happens when we use the input functions. These functions create a data frame called input (under the hood), with a column for each input selected, named after the inputID. Essentially, in our example already we’ve created this: input &lt;- data.frame(&#39;species&#39; = c(&quot;All&quot;, unique(as.character(penguins$species)))) input ## species ## 1 All ## 2 Adelie ## 3 Gentoo ## 4 Chinstrap With that in mind, we need to use that input data frame to identify our “filtered data”. We can call this whatever we want, but I think based on how we’re setting up this page, we can call it “filtered data.” Anyway, the idea is that you are writing a function that will create a new data frame every time the selector inputs are changed. That new data frame will represent the conditions set by your inputs. This is the hardest step because it forces you to think about the conditionality and shape of your data. In our example, we will call our function filteredData (though we could call this anything), and we will create it using the reactive function. Inside this reactive function, using curly brackets, we will define the conditions based on which we filter our data. You can use any conditional you want: if...else, ifelse(), case_when(). Here I use if...else because I think it is easier to read. ```{r} filteredData &lt;- reactive({ if(input$species == &quot;All&quot;){ penguins } else { penguins %&gt;% filter(species == input$species) } }) ``` So now we have this reactive function called filteredData(). The second part of this, wrapping our figure in the correct function, is easier. We just change two things: 1. We need to replace our static data with the reactive data function, which we called filteredData. And then 2. We need to wrap the whole plot in a function called renderPlot(). ```{r} renderPlot({ ggplot(filteredData(), aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) }) ``` 4.1.3 runtime: shiny The third and final ingredient to turn your dashboard into something that is dynamically interactive is to integrate Shiny. We do this by adding one line to our YAML and making sure we load the shiny package into R. In the end, your Rmd file should look like this: --- title: &#39;Palmer Penguin Dashboard&#39; runtime: shiny output: flexdashboard::flex_dashboard: --- ```{r, echo = F, warning = F, message = F} library(tidyverse) library(palmerpenguins) library(plotly) library(shiny) ``` ## Column {.sidebar} ```{r} selectInput(&quot;species&quot;, &quot;Species&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$species))), selected=&quot;All&quot;, multiple=F) ``` ```{r} filteredData &lt;- reactive({ if(input$species == &quot;All&quot;){ penguins } else { penguins %&gt;% filter(species == input$species) } }) ``` ## Column ### Relationship between penguin bill length and depth ```{r} renderPlot({ ggplot(filteredData(), aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3, color = &quot;#51127C&quot;) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) }) ``` If you make this final change and click save, you’ll notice that the Knit button disappears and is replaced with a Run document button. This is your Rmd becoming shinier. If you click run, take a look. You should now have a reactive page! Now, to make sure we understand the logic of aligning inputs and outputs, let’s try adding a few more variables to the mix. We initially wanted users to be able to make one of 64 plots, based on species, island, and year. So let’s add those other two selectors, and we can use different types just to mix it up. ```{r} selectInput(&quot;species&quot;, &quot;Species&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$species))), selected=&quot;All&quot;, multiple=F) radioButtons(&quot;island&quot;, &quot;Island&quot;, choices=c(&quot;All&quot;, unique(as.character(penguins$island))), selected=&quot;All&quot;) sliderInput(&quot;year&quot;, &quot;Year&quot;, min = min(penguins$year), max = max(penguins$year), value = median(penguins$year), step = 1) ``` Now, whenever we add more inputs, we have to update our data filtering function to react to them. Now that we have several inputs we need several conditions. I like to create intermediate versions of the filtered data, which I signify by appening the letter of the input in each condition. ```{r} filteredData &lt;- reactive({ if(input$species == &quot;All&quot;){ penguins_s &lt;- penguins } else { penguins_s &lt;- penguins %&gt;% filter(species == input$species) } if(input$island == &quot;All&quot;){ penguins_si &lt;- penguins_s } else { penguins_si &lt;- penguins_s %&gt;% filter(island == input$island) } penguins_siy &lt;- filter(penguins_si, year == input$year) return(penguins_siy) }) ``` Now because all of this is changing the data that feeds into the figure, but not any parameters of the figure itself, we don’t need to change the output portion. Everything that get’s added is in the input/UI side and the backend of filtering the data. 4.2 Selecting by different columns Now, let’s think of another user scenario. Let’s say we didn’t want to filter/reduce the data, but instead, we wanted to color the points of the plot by different variables. In this scenario, we don’t need to change the shape of the data at all, just make one of the arguments in the figure creation reactive to the inputs. So, let’s think about this first on the input side. Let’s create a drop down of variables that we want to color the nodes by. ```{r} selectInput(&quot;fill_var&quot;, &quot;Color points by...&quot;, choices=c(&quot;None&quot;, &quot;species&quot;, &quot;island&quot;, &quot;year&quot;), selected=&quot;None&quot;, multiple=F) ``` Now, think about what our under-the-food input data from looks like. It will only have one column: input$fill_var. This input value is going to specify if we want to color by a given variable, and if so, which column. So instead of making the data filtering conditional on our input, we can make the plot conditional on the input. Here we can specify, if the fill variable input is selected to “None”, just make the plot with no fill. But otherwise, inser input$fill_var as the fill. ```{r} renderPlot({ if(input$fill_var == &quot;None&quot;){ # Make the same plot as before ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point(size = 3) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) } else { # Add in the input, make sure to evaluate the parsed text so that R # thinks of it as a variable and not just text ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = eval(parse(text = input$fill_var)))) + geom_point(size = 3) + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;, color = &quot;&quot;) + scale_color_viridis_d(end = .8) } }) ``` BUT, when we try this we get a frustrating result. It is evaluating input$fill_var as text, not as a column name in the data frame. How do we get around this? We have to be very specific with R, telling it to evaluate the text as an object. We don’t get too much into this, but we will do it using these two functions: eval(parse(text = input$fill_var)) So when we add that in, we get what we want: ```{r} renderPlot({ if(input$fill_var == &quot;None&quot;){ # Make the same plot as before ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;) } else { # Add in the input, make sure to evaluate the parsed text so that R # thinks of it as a variable and not just text ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = eval(parse(text = input$fill_var)))) + geom_point() + theme_minimal() + labs(x = &quot;Length (mm)&quot;, y = &quot;Depth (mm)&quot;, color = &quot;&quot;) } }) ``` Note there are several different ways to play around with the reactive() function that could perhaps be used here, so I am demonstrating just one way to work with this. Mind the Note in Introduction: We are NOT learning full-blown Shiny.↩︎ Note: Not all of these inputs are accessible/screen-reader friendly (e.g. slider’s are harder for screen-readers than discrete boxes).↩︎ "],["themes-and-styling.html", "5 Themes and styling 5.1 Built-in themes 5.2 Custom themes", " 5 Themes and styling Once you have your interactive features built in, some of the finishing stages are to add styles to make the page more personalized. We’ll briefly review two ways to do this: built-in (pre-made) themes and custom themes. 5.1 Built-in themes You can choose from pre-set themes by selecting a theme in your YAML. These pre-set themes are defined by Bootswatch via bslib. You can look at the pre-set themes here for Version 3 and Version 4. Likewise, if you have bslib and bsicons installed, you can also run this line of code in your console to open up a demo page that has theme and formatting selectors that can be changed. bslib::bs_theme_preview() Once you choose a pre-set theme, add it to your YAML. For example, I am selecting the ‘sketchy’ theme from Bootswatch Version 4. --- output: flexdashboard::flex_dashboard: theme: version: 4 bootswatch: sketchy --- Now if we run the page with this theme setting, we can see the look of our page change. 5.2 Custom themes You can also customize your themes by outlining each component of the format you want in the YAML. The trick is knowing what each abbreviation stands for. Here are some helpers: main background color (bg), foreground color (fg), accent colors (primary, secondary, etc), and fonts (base_font, heading_font, code_font, etc). You would add these to your YAML like this: --- output: flexdashboard::flex_dashboard: theme: bg: &quot;#F0F0F0&quot; # light gray background fg: &quot;#000000&quot; # black for fonts that are foregrounded primary: &quot;#2C728E&quot; # blue nav bar secondary: &quot;#472D7B&quot; # can&#39;t see this anywhere base_font: google: &quot;Poppins&quot; --- Admittedly, I am still learning what each abbreviation stands for. I often look at others’ sites and draw on their own custom edits, tweak them, and find what works. Finally, I want to mention that there is a matter of styling with CSS, but that is beyond the scope of this lesson. If you check out the bottom of the flexdashboard theme page, you’ll see a custom CSS penguins page. "],["publishing.html", "6 Publishing", " 6 Publishing "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
